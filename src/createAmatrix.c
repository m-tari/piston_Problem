#include "main_fsi.h"

void createAmatrix(_FLOAT **A)
{
	int N = bagF->N; 
	/* Boundary condition for i=0 and i=N nodes */
	/* i=1 */
	A[5][0] = 1.0; A[6][0] = 1.0; A[7][0] = 1.0; A[8][0] = -1.0; A[9][0]  = -1.0; A[10][0] = -1.0;
	A[4][1] = 1.0; A[5][1] = 1.0; A[6][1] = 1.0; A[7][1] = -1.0; A[8][1]  = -1.0; A[9][1]  = -1.0;
	A[3][2] = 1.0; A[4][2] = 1.0; A[5][2] = 1.0; A[6][2] = -1.0; A[7][2]  = -1.0; A[8][2]  = -1.0;

	/* i=N */
	A[2][3*N-3] = -1.0; A[3][3*N-3] = -1.0; A[4][3*N-3] = -1.0; A[5][3*N-3] = 1.0; A[6][3*N-3] = 1.0; A[7][3*N-3] = 1.0;
	A[1][3*N-2] = -1.0; A[2][3*N-2] = -1.0; A[3][3*N-2] = -1.0; A[4][3*N-2] = 1.0; A[5][3*N-2] = 1.0; A[6][3*N-2] = 1.0;
	A[0][3*N-1] = -1.0; A[1][3*N-1] = -1.0; A[2][3*N-1] = -1.0; A[3][3*N-1] = 1.0; A[4][3*N-1] = 1.0; A[5][3*N-1] = 1.0;

	for (int i = 2; i <= bagF->N-1; ++i)
	{
		/* first row */
		A[2][3*(i-1)]  = 0.0;
		A[3][3*(i-1)]  = -(bagF->dt/(4.0*bagF->dx))*1.0;
		A[4][3*(i-1)]  = 0.0;
		A[5][3*(i-1)]  = 1.0;
		A[6][3*(i-1)]  = 1.0;
		A[7][3*(i-1)]  = 1.0;
		A[8][3*(i-1)]  = 0.0;
		A[9][3*(i-1)]  = (bagF->dt/(4.0*bagF->dx))*1.0;
		A[10][3*(i-1)] = 0.0;
		/* second row */
		A[1][3*(i-1)+1] = -(bagF->dt/(4.0*bagF->dx))*(gam-3)*pow(bagF->u[i-1],2)/2.0;
		A[2][3*(i-1)+1] = -(bagF->dt/(4.0*bagF->dx))*(3.0-gam)*bagF->u[i-1];
		A[3][3*(i-1)+1] = -(bagF->dt/(4.0*bagF->dx))*(gam-1.0);
		A[4][3*(i-1)+1] = 1.0;
		A[5][3*(i-1)+1] = 1.0;
		A[6][3*(i-1)+1] = 1.0;
		A[7][3*(i-1)+1] = (bagF->dt/(4.0*bagF->dx))*(gam-3)*pow(bagF->u[i+1],2)/2.0;
		A[8][3*(i-1)+1] = (bagF->dt/(4.0*bagF->dx))*(3.0-gam)*bagF->u[i+1];
		A[9][3*(i-1)+1] = (bagF->dt/(4.0*bagF->dx))*(gam-1.0);	
		/* third row */
		A[0][3*(i-1)+2] = -(bagF->dt/(4.0*bagF->dx))*((gam-1)*pow(bagF->u[i-1],3)-gam*bagF->u[i-1]*bagF->e[i-1]/bagF->rho[i-1]);
		A[1][3*(i-1)+2] = -(bagF->dt/(4.0*bagF->dx))*(-(3.0/2.0)*(gam-1)*pow(bagF->u[i-1],2) + gam*bagF->e[i-1]/bagF->rho[i-1]);
		A[2][3*(i-1)+2] = -(bagF->dt/(4.0*bagF->dx))*gam*bagF->u[i-1];
		A[3][3*(i-1)+2] = 1.0;
		A[4][3*(i-1)+2] = 1.0;
		A[5][3*(i-1)+2] = 1.0;
		A[6][3*(i-1)+2] = (bagF->dt/(4.0*bagF->dx))*((gam-1)*pow(bagF->u[i+1],3)-gam*bagF->u[i+1]*bagF->e[i+1]/bagF->rho[i+1]);
		A[7][3*(i-1)+2] = (bagF->dt/(4.0*bagF->dx))*(-(3.0/2.0)*(gam-1)*pow(bagF->u[i+1],2) + gam*bagF->e[i+1]/bagF->rho[i+1]);
		A[8][3*(i-1)+2] = (bagF->dt/(4.0*bagF->dx))*gam*bagF->u[i+1];
	} 
}